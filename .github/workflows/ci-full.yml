name: CI Integration Workflow (Full)

on:
  push:
    branches: [ main, master, develop ]
    paths-ignore:
      - '*.md'
      - '**/*.md'
      - 'docs/**'
      - 'README*'
      - 'CHANGELOG*'
      - 'LICENSE*'
      - 'SECURITY.md'
      - 'ASSESSMENT.md'
      - 'SOPS_WRAPPER_README.md'
      - '.gitignore'
      - '.gitleaks.toml'
      - 'DevOps Assessment CDK.txt'
  # Remove pull_request trigger - handled by ci-feature.yml
  schedule:
    # Run daily security scans at 2 AM UTC (ignores paths-ignore)
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests for emergency deployments'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.13'
  ECR_REPOSITORY: testapp

# Global permissions for all jobs
permissions:
  contents: read
  security-events: write
  actions: read
  checks: write
  pull-requests: write
  id-token: write  # For AWS OIDC

jobs:
  secret-scan:
    name: Secret Scanning
    runs-on: ${{ vars.RUNS_ON }}
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for comprehensive scanning

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}
          GITLEAKS_CONFIG: .gitleaks.toml
          GITLEAKS_VERSION: latest

      - name: Upload Gitleaks SARIF (if Code Scanning enabled)
        if: always() && github.event_name != 'pull_request'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results.sarif
          category: gitleaks
        continue-on-error: true

      - name: Upload Gitleaks results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-results
          path: results.sarif
        continue-on-error: true

  dependency-scan:
    name: Dependency Vulnerability Scan
    runs-on: ${{ vars.RUNS_ON }}
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python and UV
        uses: astral-sh/setup-uv@v2
        with:
          version: "latest"
          enable-cache: true
          cache-dependency-glob: "pyproject.toml"

      - name: Install dependencies
        run: uv sync --all-extras

      - name: Generate requirements-snyk.txt for Snyk
        run: make requirements-snyk

      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/python@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --package-manager=pip --file=requirements-snyk.txt --project-name=testapp --sarif-file-output=snyk.sarif
          
      - name: Create empty SARIF if Snyk didn't generate one
        if: always()
        run: |
          if [ ! -f snyk.sarif ]; then
            echo '{"version":"2.1.0","$schema":"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json","runs":[{"tool":{"driver":{"name":"Snyk","version":"1.0.0"}},"results":[]}]}' > snyk.sarif
          fi

      - name: Upload Snyk results to GitHub Code Scanning (if enabled)
        if: always() && github.event_name != 'pull_request'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: snyk.sarif
          category: snyk
        continue-on-error: true

      - name: Upload Snyk results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: snyk-results
          path: snyk.sarif
        continue-on-error: true

      - name: Snyk Monitor (Track dependencies)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: snyk/actions/python@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: monitor
          args: --package-manager=pip --file=requirements-snyk.txt --project-name=testapp --skip-unresolved

  # Job 3: SAST (Static Application Security Testing)
  sast-scan:
    name: Static Application Security Testing
    runs-on: ${{ vars.RUNS_ON }}
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python and UV
        uses: astral-sh/setup-uv@v2
        with:
          version: "latest"
          enable-cache: true
          cache-dependency-glob: "pyproject.toml"

      - name: Install dependencies
        run: uv sync --all-extras

      - name: Install security tools
        run: |
          uv pip install bandit[toml] safety
          pip install semgrep

      - name: Run Bandit (Python Security Linter)
        run: |
          uv run bandit -r src/testapp/ -f json -o bandit-report.json || true
          uv run bandit -r src/testapp/ -f txt

      - name: Run Safety (Known Security Vulnerabilities)
        run: |
          uv run safety check --json --output safety-report.json || true
          uv run safety check

      - name: Run Semgrep (SAST)
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        run: |
          semgrep --config=auto --json --output=semgrep-report.json src/ || true
          semgrep --config=auto src/

      - name: Upload SAST results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sast-reports
          path: |
            bandit-report.json
            safety-report.json
            semgrep-report.json

  container-scan:
    name: Container Security Scan
    runs-on: ${{ vars.RUNS_ON }}
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for scanning
        run: |
          docker build -f Dockerfile -t testapp:scan-latest .

      - name: Install Trivy
        run: |
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy

      - name: Run Trivy vulnerability scanner
        run: |
          trivy image --format sarif --output trivy-results.sarif testapp:scan-latest || true
          trivy image --severity HIGH,CRITICAL testapp:scan-latest

      - name: Upload Trivy scan results to GitHub Code Scanning (if enabled)
        if: always() && github.event_name != 'pull_request'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results.sarif
          category: trivy
        continue-on-error: true

      - name: Upload Trivy results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results
          path: trivy-results.sarif
        continue-on-error: true

      - name: Run Snyk Container scan
        if: env.SNYK_TOKEN != ''
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: testapp:scan-latest
          args: --severity-threshold=high --fail-on=upgradable

  license-scan:
    name: License Compliance Scan
    runs-on: ${{ vars.RUNS_ON }}
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python and UV
        uses: astral-sh/setup-uv@v2
        with:
          version: "latest"
          enable-cache: true
          cache-dependency-glob: "pyproject.toml"

      - name: Install dependencies
        run: uv sync --all-extras

      - name: Install license scanner
        run: uv pip install pip-licenses

      - name: Scan Python licenses
        run: |
          uv run pip-licenses --format=json --output-file python-licenses.json
          uv run pip-licenses --format=plain

      - name: Upload license scan results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: license-reports
          path: python-licenses.json

  policy-validation:
    name: Security Policy Validation
    runs-on: ${{ vars.RUNS_ON }}
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') && github.event_name == 'pull_request' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for security policy compliance
        run: |
          # Check for SECURITY.md
          if [ ! -f "SECURITY.md" ]; then
            echo "❌ SECURITY.md file is missing"
            exit 1
          fi
          
          # Check for sensitive files in git history
          if git log --all --full-history --pretty=format: --name-only | grep -E '\.(key|pem|p12|jks)$'; then
            echo "❌ Sensitive files detected in git history"
            exit 1
          fi
          
          # Check Django settings for production readiness
          if grep -q "DEBUG = True" src/testapp/settings.py; then
            echo "❌ DEBUG mode is enabled in settings.py"
            exit 1
          fi
          
          echo "✅ Basic security policy checks passed"

  security-summary:
    name: Security Summary
    runs-on: ${{ vars.RUNS_ON }}
    needs: [secret-scan, dependency-scan, sast-scan, container-scan, license-scan, policy-validation]
    if: ${{ always() && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Generate Security Summary
        run: |
          echo "# Security Scan Summary" > security-summary.md
          echo "Date: $(date)" >> security-summary.md
          echo "Commit: ${{ github.sha }}" >> security-summary.md
          echo "" >> security-summary.md
          
          echo "## Scan Results:" >> security-summary.md
          echo "- ✅ Secret Scanning (Gitleaks): ${{ needs.secret-scan.result }}" >> security-summary.md
          echo "- ✅ Dependency Scanning (Snyk): ${{ needs.dependency-scan.result }}" >> security-summary.md
          echo "- ✅ SAST Scanning: ${{ needs.sast-scan.result }}" >> security-summary.md
          echo "- ✅ Container Scanning: ${{ needs.container-scan.result }}" >> security-summary.md
          echo "- ✅ License Scanning: ${{ needs.license-scan.result }}" >> security-summary.md
          
          cat security-summary.md

      - name: Upload Security Summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-summary
          path: security-summary.md

      - name: Comment PR with Security Summary
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('security-summary.md', 'utf8');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## 🔒 Security Scan Results\n\n${summary}`
            });

  tests:
    name: Tests Code
    runs-on: ${{ vars.RUNS_ON }}     
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') }} 
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Cache UV dependencies
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            ~/.cache/uv
            .venv
          key: uv-${{ runner.os }}-${{ hashFiles('pyproject.toml', 'uv.lock') }}
          restore-keys: |
            uv-${{ runner.os }}-
          
      - name: Setup Python and UV
        uses: astral-sh/setup-uv@v2
        with:
          version: "latest"
          enable-cache: true
          cache-dependency-glob: "pyproject.toml"
          
      - name: Cache SOPS binary
        uses: actions/cache@v4
        continue-on-error: true
        id: cache-sops
        with:
          path: /tmp/sops.deb
          key: sops-3.10.2-amd64
          
      - name: Install SOPS
        run: |
          # Download SOPS if not cached
          if [ ! -f /tmp/sops.deb ]; then
            echo "Downloading SOPS..."
            wget -O /tmp/sops.deb https://github.com/mozilla/sops/releases/download/v3.10.2/sops_3.10.2_amd64.deb
          else
            echo "Using cached SOPS binary"
          fi
          
          # Install SOPS
          sudo dpkg -i /tmp/sops.deb
          
      - name: Install application dependencies
        run: |
          uv sync --group dev
          
      - name: Run security scanning with Semgrep
        run: |
          uv run semgrep --config=auto src/ || true
          
      - name: Test database migrations
        env:
          SECRET_KEY: django-test-secret-key-for-ci
          ENVIRONMENT: testing
          DEBUG: false
          REQUIRED_SETTING: test-value-for-ci
          EMAIL_URL: smtp://localhost:25
        run: |
          mkdir -p logs
          mkdir -p src/static
          cd src
          # Test migrations can be applied cleanly
          echo "Testing database migration process..."
          uv run python manage.py migrate --check || {
            echo "Migration check failed, attempting to apply migrations..."
            uv run python manage.py migrate
            echo "✅ Migrations applied successfully"
          }
          # Test migrations can be run multiple times safely (idempotent)
          uv run python manage.py migrate
          echo "✅ Migration idempotency test passed"

      - name: Test application with coverage
        env:
          SECRET_KEY: django-test-secret-key-for-ci
          ENVIRONMENT: testing
          DEBUG: false
          REQUIRED_SETTING: test-value-for-ci
          EMAIL_URL: smtp://localhost:25
        run: |
          mkdir -p logs
          mkdir -p src/static
          cd src
          uv run coverage run --source='testapp' manage.py test
          uv run coverage report
          uv run coverage xml -o coverage.xml

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./src/coverage.xml
          fail_ci_if_error: false
          verbose: true
        continue-on-error: true

  infrastructure-test:
    name: Test Infrastructure Code
    runs-on: ${{ vars.RUNS_ON }}
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: infrastructure/package-lock.json

      - name: Install infrastructure dependencies
        run: |
          cd infrastructure
          npm ci

      - name: Build TypeScript
        run: |
          cd infrastructure
          npm run build

      - name: Run infrastructure tests
        run: |
          cd infrastructure
          npm test

      - name: Synthesize CloudFormation
        run: |
          cd infrastructure
          npm run synth

      - name: Upload CloudFormation templates
        uses: actions/upload-artifact@v4
        with:
          name: cloudformation-templates
          path: infrastructure/cdk.out/*.template.json
          retention-days: 30

  build:
    name: Build and Push Docker Image
    runs-on: ${{ vars.RUNS_ON }}
    needs: [secret-scan, dependency-scan, sast-scan, container-scan, license-scan, tests, infrastructure-test]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    concurrency:
      group: build-${{ github.ref }}
      cancel-in-progress: false
    
    permissions:
      id-token: write
      contents: write
      pull-requests: write
      issues: write
    
    steps:
      - name: GitHub Actions Bot Configuration
        id: bot_config
        env:
          GITHUB_BOT_EMAIL: 'github-actions[bot]@users.noreply.github.com'
          GITHUB_BOT_USERNAME: "github-actions[bot]"
        shell: bash -l {0}
        run: |
          #!/usr/bin/env bash

          set -euo pipefail

          echo "GITHUB_BOT_EMAIL=${{ env.GITHUB_BOT_EMAIL }}" >> $GITHUB_ENV
          echo "GITHUB_BOT_USERNAME=${{ env.GITHUB_BOT_USERNAME }}" >> $GITHUB_ENV

          git config --global author.email "${{ env.GITHUB_BOT_EMAIL }}"
          git config --global author.name "${{ env.GITHUB_BOT_USERNAME }}"
          git config --global committer.email "${{ env.GITHUB_BOT_EMAIL }}"
          git config --global committer.name "${{ env.GITHUB_BOT_USERNAME }}"
          git config --global init.defaultBranch ${{ github.event.repository.default_branch }}
          git config --global pull.ff only
          git config --global pull.rebase true
          git config --global push.autosetupremote true
          git config --global push.followTags true
          git config --global user.email "${{ env.GITHUB_BOT_EMAIL }}"
          git config --global user.name "${{ env.GITHUB_BOT_USERNAME }}"

          echo "Initializing Git Repository..."
          git init ${{ github.workspace }}
          
          echo "bot_email=${{ env.GITHUB_BOT_EMAIL }}" >> $GITHUB_OUTPUT
          echo "bot_user=${{ env.GITHUB_BOT_USERNAME }}" >> $GITHUB_OUTPUT

      - name: Generate GitHub App Token
        uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}
          
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install GitVersion
        id: install_gitversion
        uses: gittools/actions/gitversion/setup@v4.1.0
        with:
          versionSpec: ${{ vars.GITVERSION_SPEC }}

      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v4.1.0
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          role-to-assume: arn:aws:iam::892193016253:role/github-actions-role
          role-session-name: github-actions
          aws-region: us-east-1
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Create ECR repository if it doesn't exist
        run: |
          # Check if repository exists, create if it doesn't
          if ! aws ecr describe-repositories --repository-names $ECR_REPOSITORY >/dev/null 2>&1; then
            echo "Creating ECR repository: $ECR_REPOSITORY"
            aws ecr create-repository \
              --repository-name $ECR_REPOSITORY \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
            
            # Set lifecycle policy to keep only the last 10 images
            aws ecr put-lifecycle-policy \
              --repository-name $ECR_REPOSITORY \
              --lifecycle-policy-text '{
                "rules": [
                  {
                    "rulePriority": 1,
                    "description": "Keep last 10 images",
                    "selection": {
                      "tagStatus": "any",
                      "countType": "imageCountMoreThan",
                      "countNumber": 10
                    },
                    "action": {
                      "type": "expire"
                    }
                  }
                ]
              }'
            
            echo "✅ ECR repository created with lifecycle policy"
          else
            echo "✅ ECR repository already exists: $ECR_REPOSITORY"
          fi

      - name: Docker Meta
        id: meta
        uses: docker/metadata-action@v5
        env:
          IMAGE: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
        with:
          images: ${{ env.IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}},value=v${{ steps.gitversion.outputs.semVer }}
            type=semver,pattern={{major}}.{{minor}},value=v${{ steps.gitversion.outputs.semVer }}
            type=edge,enable=true,priority=700,prefix=,suffix=,branch=${{ github.ref_name == github.event.repository.default_branch }}
          flavor: |
            latest=${{ github.ref_name == github.event.repository.default_branch }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker BuildX
        uses: docker/setup-buildx-action@v3

      - name: Docker Build and Push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          build-args: |
            COMMITSHA=${{ steps.gitversion.outputs.sha }}
            COMMITSHASHORT=${{ steps.gitversion.outputs.shortSha }}
            VERSION=${{ steps.gitversion.outputs.semVer }}
          labels: ${{ steps.meta.outputs.labels }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}          

      - name: Tag
        id: tag
        shell: bash -l {0}
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          #!/usr/bin/env bash

          function version_compare() {
            # Compare two semantic versions
            # Returns: 0 if equal, 1 if $1 > $2, 2 if $1 < $2
            if [[ "$1" == "$2" ]]; then
              return 0
            fi
            
            local IFS=.
            local i ver1=($1) ver2=($2)
            
            # Fill empty fields with zeros
            for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
              ver1[i]=0
            done
            for ((i=${#ver2[@]}; i<${#ver1[@]}; i++)); do
              ver2[i]=0
            done
            
            # Compare each component
            for ((i=0; i<${#ver1[@]}; i++)); do
              if [[ ${ver1[i]} -gt ${ver2[i]} ]]; then
                return 1
              fi
              if [[ ${ver1[i]} -lt ${ver2[i]} ]]; then
                return 2
              fi
            done
            return 0
          }

          function should_update_tag() {
            local TARGET_TAG=$1
            local CURRENT_VERSION=$2
            
            # Get existing tag version if it exists
            local EXISTING_VERSION=$(git ls-remote -q --tags | grep "refs/tags/${TARGET_TAG}$" | head -1)
            if [[ -z "$EXISTING_VERSION" ]]; then
              echo "true"  # No existing tag, safe to create
              return
            fi
            
            # Extract the base version from current (remove build number)
            local CURRENT_BASE=${CURRENT_VERSION#v}
            CURRENT_BASE=${CURRENT_BASE%-*}  # Remove -XX build number
            
            # For TARGET_TAG, we need to check what base version it represents
            local TARGET_BASE=""
            case "$TARGET_TAG" in
              v[0-9]*.[0-9]*.[0-9]*)  # v0.0.1 format
                TARGET_BASE=${TARGET_TAG#v}
                ;;
              v[0-9]*.[0-9]*)         # v0.0 format
                TARGET_BASE=${TARGET_TAG#v}
                ;;
              v[0-9]*)                # v0 format
                TARGET_BASE=${TARGET_TAG#v}
                ;;
            esac
            
            # If current version starts with the target base, it should update the tag
            # Example: v0.0.1-20 should update v0.0.1, v0.0, v0 tags
            if [[ "$CURRENT_BASE" == "$TARGET_BASE"* ]]; then
              echo "true"  # Same base version or newer, allow update
              return
            fi
            
            # Compare base versions to see if current is newer
            version_compare "$CURRENT_BASE" "$TARGET_BASE"
            case $? in
              0|1) echo "true" ;;   # Current >= Target base, allow update
              2) echo "false" ;;    # Current < Target base, prevent overwrite
            esac
          }

          function tagger() {
            VERSION=$1
            echo "Releasing Version: ${VERSION}"
            
            # For specific semver tags (with build numbers), always proceed
            if [[ "$VERSION" =~ -[0-9]+$ ]]; then
              TAG_EXISTS=$(git ls-remote -q --tags | grep -q "refs/tags/${VERSION}$" && echo true || echo false)
              if [[ "${TAG_EXISTS}" = true ]]; then
                HAS_RELEASE=$(gh release list --json tagName -q '.[].tagName' | grep -E "^(${VERSION})$" && echo true || echo false)
                if [[ "${HAS_RELEASE}" == true ]]; then
                  gh release delete --yes ${VERSION}
                fi
                git push origin --delete ${VERSION}
                git tag -d ${VERSION}
              fi
            else
              # For major/minor tags, check if we should update
              local CURRENT_SEMVER="v${{ steps.gitversion.outputs.semVer }}"
              local SHOULD_UPDATE=$(should_update_tag "$VERSION" "$CURRENT_SEMVER")
              
              if [[ "$SHOULD_UPDATE" == "false" ]]; then
                echo "⚠️  Skipping $VERSION - current version ($CURRENT_SEMVER) is older than existing tag"
                return
              fi
              
              TAG_EXISTS=$(git ls-remote -q --tags | grep -q "refs/tags/${VERSION}$" && echo true || echo false)
              if [[ "${TAG_EXISTS}" = true ]]; then
                echo "🔄 Updating existing tag $VERSION with newer version"
                HAS_RELEASE=$(gh release list --json tagName -q '.[].tagName' | grep -E "^(${VERSION})$" && echo true || echo false)
                if [[ "${HAS_RELEASE}" == true ]]; then
                  gh release delete --yes ${VERSION}
                fi
                git push origin --delete ${VERSION}
                git tag -d ${VERSION}
              fi
            fi

            echo
            git tag -a ${VERSION} -m "chore: Release Version ${VERSION}"
            git push -f --tags --follow-tags
            git push --set-upstream origin ${{ github.ref_name }}
            echo
            echo
          }

          tagger "v${{ steps.gitversion.outputs.semVer }}"
          if [[ "${{ github.ref_name  }}" == "${{ github.event.repository.default_branch }}" ]];
          then
            tagger "v${{ steps.gitversion.outputs.majorMinorPatch }}"
            tagger "v${{ steps.gitversion.outputs.major }}.${{ steps.gitversion.outputs.minor }}"
            tagger "v${{ steps.gitversion.outputs.major }}"
          fi

      - name: Release
        id: release
        shell: bash -l {0}
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          #!/usr/bin/env bash

          if [[ "${{ github.ref_name  }}" == "${{ github.event.repository.default_branch }}" ]];
          then
            gh release list | grep Draft | awk '{print $1 " \t"}' | while read -r draft; do echo "Removing Draft Releases: ${draft}"; gh release delete --yes "${draft}"; done
            gh release create v${{ steps.gitversion.outputs.semVer }} --generate-notes --verify-tag --latest
          fi

  deploy-development:
    name: Deploy Infrastructure
    runs-on: ${{ vars.RUNS_ON }}
    needs: [build, infrastructure-test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    concurrency:
      group: deploy-development-${{ github.ref }}
      cancel-in-progress: false
    environment: 
      name: development
      url: ${{ steps.deploy.outputs.application_url }}
    
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          role-to-assume: arn:aws:iam::892193016253:role/github-actions-role
          role-session-name: github-actions
          aws-region: us-east-1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: infrastructure/package-lock.json

      - name: Install AWS CDK
        run: npm install -g aws-cdk@latest

      - name: Install infrastructure dependencies
        run: |
          cd infrastructure
          npm ci

      - name: Build infrastructure
        run: |
          cd infrastructure
          npm run build

      - name: Download CloudFormation templates
        uses: actions/download-artifact@v4
        with:
          name: cloudformation-templates
          path: infrastructure/cdk.out/

      - name: Wait for existing stack operations
        timeout-minutes: 30
        run: |
          echo "## ⏳ Checking for Active Stack Operations" >> $GITHUB_STEP_SUMMARY
          
          # Function to wait for stack to be in a stable state
          wait_for_stack() {
            local stack_name=$1
            local max_attempts=30
            local attempt=1
            
            echo "Checking stack: $stack_name"
            
            while [ $attempt -le $max_attempts ]; do
              status=$(aws cloudformation describe-stacks --stack-name $stack_name --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_FOUND")
              
              case $status in
                "CREATE_COMPLETE"|"UPDATE_COMPLETE"|"ROLLBACK_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE"|"NOT_FOUND")
                  echo "✅ Stack $stack_name is ready (Status: $status)"
                  return 0
                  ;;
                "CREATE_IN_PROGRESS"|"UPDATE_IN_PROGRESS"|"DELETE_IN_PROGRESS"|"ROLLBACK_IN_PROGRESS"|"UPDATE_ROLLBACK_IN_PROGRESS")
                  echo "⏳ Stack $stack_name is busy (Status: $status), waiting... (attempt $attempt/$max_attempts)"
                  sleep 60
                  ;;
                "CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED")
                  echo "❌ Stack $stack_name is in failed state: $status"
                  return 1
                  ;;
                *)
                  echo "⚠️ Unknown stack status: $status"
                  sleep 30
                  ;;
              esac
              
              attempt=$((attempt + 1))
            done
            
            echo "❌ Timeout waiting for stack $stack_name to be ready"
            return 1
          }
          
          # Wait for each development stack to be ready
          wait_for_stack "TestApp-VPC-dev" || true
          wait_for_stack "TestApp-Platform-dev" || true
          wait_for_stack "TestApp-App-dev" || true
          
          echo "✅ All development stacks are ready for deployment" >> $GITHUB_STEP_SUMMARY

      - name: Deploy infrastructure
        id: deploy
        timeout-minutes: 30
        run: |
          cd infrastructure
          
          # Acknowledge CDK notices
          npx cdk acknowledge 34892 34635 || true
          
          # Deploy development stacks in dependency order with timeout configuration
          npx cdk deploy TestApp-VPC-dev --require-approval never --context environment=dev --cli-read-timeout 1500
          npx cdk deploy TestApp-Platform-dev --require-approval never --context environment=dev --cli-read-timeout 1500
          npx cdk deploy TestApp-App-dev --require-approval never --context environment=dev --outputs-file outputs.json --cli-read-timeout 1500
          
          # Extract application URL from outputs
          APPLICATION_URL=$(jq -r '.["TestApp-App-dev"]["ApplicationUrl"] // empty' outputs.json)
          if [[ -n "$APPLICATION_URL" ]]; then
            echo "application_url=$APPLICATION_URL" >> $GITHUB_OUTPUT
          fi
          
          # Display deployment summary
          echo "## 🚀 Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          
          if [[ -f outputs.json ]]; then
            jq -r '.["TestApp-App-dev"] | to_entries[] | "| \(.key) | \(.value) |"' outputs.json >> $GITHUB_STEP_SUMMARY
          fi

      - name: Run infrastructure smoke tests
        run: |
          # Wait for service to be healthy
          if [[ -n "${{ steps.deploy.outputs.application_url }}" ]]; then
            echo "Running smoke tests against: ${{ steps.deploy.outputs.application_url }}"
            
            # Wait up to 5 minutes for the service to be ready
            timeout 300 bash -c '
              until curl -sf "${{ steps.deploy.outputs.application_url }}/health/" > /dev/null; do
                echo "Waiting for service to be ready..."
                sleep 10
              done
              echo "Service is ready!"
            '
            
            # Test the application endpoints
            curl -f "${{ steps.deploy.outputs.application_url }}/" 
            curl -f "${{ steps.deploy.outputs.application_url }}/health/"
            
            echo "✅ Infrastructure smoke tests passed"
          else
            echo "⚠️ No application URL found, skipping smoke tests"
          fi

  # Manual approval for production deployments
  production-approval:
    name: 'Production Deployment Approval'
    runs-on: ${{ vars.RUNS_ON }}
    needs: [deploy-development]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && contains(github.event.head_commit.message, '[deploy-prod]')
    environment:
      name: production-approval
    
    permissions:
      contents: read
      issues: write
      pull-requests: write
    
    steps:
      - name: Generate GitHub App Token
        uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}

      - name: Download Infrastructure Templates
        uses: actions/download-artifact@v4
        with:
          name: cloudformation-templates
          path: infrastructure/cdk.out/

      - name: Create Deployment Summary
        run: |
          echo "## 🚨 Production Deployment Approval Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Operation:** Infrastructure Deployment" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** production" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### 📋 Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### 🏗️ Infrastructure Changes" >> $GITHUB_STEP_SUMMARY
          if [ -d "infrastructure/cdk.out" ]; then
            echo "- CDK Templates: $(find infrastructure/cdk.out -name "*.template.json" | wc -l) files" >> $GITHUB_STEP_SUMMARY
            echo "- Stack Name: TestApp-production" >> $GITHUB_STEP_SUMMARY
            echo "- AWS Region: ${{ vars.AWS_DEFAULT_REGION || 'us-east-1' }}" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Manual Approval Required
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ steps.app-token.outputs.token }}
          approvers: ${{ vars.PRODUCTION_APPROVERS || github.repository_owner }}
          minimum-approvals: 1
          issue-title: "🚨 Production Infrastructure Deployment Approval Required"
          issue-body: |
            ## 🚀 Production Infrastructure Deployment Approval

            **Environment:** production
            **Operation:** CDK Infrastructure Deployment  
            **Stack:** TestApp-production
            **Commit:** ${{ github.sha }}
            **Author:** ${{ github.actor }}

            ### ⚠️ Important Security Notice
            This operation will deploy infrastructure changes to the **PRODUCTION** environment. 
            
            **Review Required:** Please carefully review all changes before approving this deployment.

            ### 🔗 Review Links
            - **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
            - **Infrastructure Code:** https://github.com/${{ github.repository }}/tree/${{ github.sha }}/infrastructure
            - **Commit Details:** https://github.com/${{ github.repository }}/commit/${{ github.sha }}
            - **CloudFormation Templates:** Available in workflow artifacts

            ### 📋 Pre-Deployment Checklist
            - [ ] Reviewed infrastructure code changes in this commit
            - [ ] Verified security configurations are appropriate
            - [ ] Confirmed resource sizing and costs are acceptable  
            - [ ] Validated deployment will not cause service disruption
            - [ ] Ensured rollback plan is available if needed

            ### 🔧 Infrastructure Components
            - **ECS Fargate Service** with auto-scaling
            - **Application Load Balancer** with health checks
            - **VPC with private/public subnets** and security groups
            - **ECR Repository** for container images
            - **CloudWatch Logs** for monitoring
            - **AWS Secrets Manager** for application secrets
            - **Optional Security Features** (WAF, VPC Flow Logs, HTTPS/TLS)

            ### ✅ Approval Instructions
            **Approvers:** ${{ vars.PRODUCTION_APPROVERS || github.repository_owner }}
            
            To approve this deployment, please:
            1. Review the infrastructure changes
            2. Verify the deployment checklist above
            3. Comment "approved" or "approve" on this issue

            > **Security Policy:** This approval is required for all production infrastructure deployments.

            ### 🛑 Emergency Contact
            If this is an emergency deployment, please contact the on-call team and include justification in your approval comment.
          exclude-workflow-initiator-as-approver: false

  deploy-production:
    name: Deploy to Production
    runs-on: ${{ vars.RUNS_ON }}
    needs: [deploy-development, production-approval]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && contains(github.event.head_commit.message, '[deploy-prod]')
    concurrency:
      group: deploy-production-${{ github.ref }}
      cancel-in-progress: false    
    environment: 
      name: production
      url: ${{ steps.deploy-prod.outputs.application_url }}
    
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials for production
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          role-to-assume: arn:aws:iam::892193016253:role/github-actions-role
          role-session-name: github-actions
          aws-region: us-east-1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: infrastructure/package-lock.json

      - name: Install AWS CDK
        run: npm install -g aws-cdk@latest

      - name: Install infrastructure dependencies
        run: |
          cd infrastructure
          npm ci

      - name: Build infrastructure
        run: |
          cd infrastructure
          npm run build

      - name: Wait for existing production stack operations
        timeout-minutes: 30
        run: |
          echo "## ⏳ Checking for Active Production Stack Operations" >> $GITHUB_STEP_SUMMARY
          
          # Function to wait for stack to be in a stable state
          wait_for_stack() {
            local stack_name=$1
            local max_attempts=30
            local attempt=1
            
            echo "Checking production stack: $stack_name"
            
            while [ $attempt -le $max_attempts ]; do
              status=$(aws cloudformation describe-stacks --stack-name $stack_name --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_FOUND")
              
              case $status in
                "CREATE_COMPLETE"|"UPDATE_COMPLETE"|"ROLLBACK_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE"|"NOT_FOUND")
                  echo "✅ Stack $stack_name is ready (Status: $status)"
                  return 0
                  ;;
                "CREATE_IN_PROGRESS"|"UPDATE_IN_PROGRESS"|"DELETE_IN_PROGRESS"|"ROLLBACK_IN_PROGRESS"|"UPDATE_ROLLBACK_IN_PROGRESS")
                  echo "⏳ Stack $stack_name is busy (Status: $status), waiting... (attempt $attempt/$max_attempts)"
                  sleep 60
                  ;;
                "CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED")
                  echo "❌ Stack $stack_name is in failed state: $status"
                  return 1
                  ;;
                *)
                  echo "⚠️ Unknown stack status for production: $status"
                  sleep 30
                  ;;
              esac
              
              attempt=$((attempt + 1))
            done
            
            echo "❌ Timeout waiting for production stack $stack_name to be ready"
            return 1
          }
          
          # Wait for production stacks to be ready
          wait_for_stack "TestApp-VPC-production" || true
          wait_for_stack "TestApp-Platform-production" || true
          wait_for_stack "TestApp-App-production" || true
          
          echo "✅ All production stacks are ready for deployment" >> $GITHUB_STEP_SUMMARY

      - name: Deploy production infrastructure
        id: deploy-prod
        timeout-minutes: 30
        run: |
          cd infrastructure
          
          # Acknowledge CDK notices
          npx cdk acknowledge 34892 34635 || true
          
          # Deploy production stacks in dependency order with timeout configuration
          npx cdk deploy TestApp-VPC-production --require-approval never --context environment=production --cli-read-timeout 1500
          npx cdk deploy TestApp-Platform-production --require-approval never --context environment=production --cli-read-timeout 1500
          npx cdk deploy TestApp-App-production --require-approval never --context environment=production --outputs-file outputs-prod.json --cli-read-timeout 1500
          
          # Extract application URL from outputs
          APPLICATION_URL=$(jq -r '.["TestApp-production"]["ApplicationUrl"] // empty' outputs-prod.json)
          if [[ -n "$APPLICATION_URL" ]]; then
            echo "application_url=$APPLICATION_URL" >> $GITHUB_OUTPUT
          fi
          
          # Display deployment summary
          echo "## 🎯 Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          
          if [[ -f outputs-prod.json ]]; then
            jq -r '.["TestApp-production"] | to_entries[] | "| \(.key) | \(.value) |"' outputs-prod.json >> $GITHUB_STEP_SUMMARY
          fi
